linux驱动的工作方式是每种驱动有probe, open, close等基本函数,加载内核的时候加载这些函数完成设备的初始化, 还有一些其他的功能函数一并被加载, 这些功能在内核层,用户不能直接调用, 需要使用ioctl的方式. 简单说, 就是通过一个socket接口, 把提前定义好的功能码和一些内容指针传递给驱动,驱动通过识别功能码完成对应功能.

驱动中关键的是TADMA, 它负责把以太网包定时发送出去,是实时性的关键. TADMA的具体功能可参照文档.
简单的说, TADMA把以太网流量按照一定类型划分成几类, 用stream-id表示. 
每一类流量有一个触发时间和发送数量, 即到这个时间硬件就发几包, 这个时间是从每个QBV周期开始算得, QBV周期是TSN模块提供的时钟信号给到TADMA, TADMA从内存中取包发送.
每种流量类型都有对应的缓存, 驱动收到要发送的包, 放入对应类型的缓存中, 等待TADMA硬件读取缓存发送. 缓存中软件增加写指针添加包, 硬件增加读指针取出包.

在驱动文件xilinx_tsn_tadma.c中, 规定了几种功能函数与配置相关.
add_stream: 添加流量类型
flush_stream: 删除所有流量类型
program: 应用流量类型配置
get_strid: 根据包的内容获得streamid
xmit: 将包写入对应缓存

app中的tadma_prog就是通过ioctl调用驱动中的这些函数, 读取配置文件配置TADMA.

TADMA配置完毕, 启用PTP同步让PTP时钟运转, 启用QBV给TADMA提供周期, 再运行TRDP应用, 就可以定时发包了.


划分流量类型的方法, 是通过一个64位的长标签, 通过哈希表获得一个短的streamid, 特别地, 我们用TRDP的目标IP和COMID作为长标签来划分流量, 见add_stream函数.
同样的, 一个待发送的包读取他的IP和COMID, 放入对应缓存中. 见get_strid函数.

QBV的周期是10ms, TRDP最小发送周期为30ms, 可以预见, 每次TADMA检查不同的COMID, 最多有1包需要发送.

最关键问题是, TADMA支持的流量类型有限,最多128种, 我们想支持尽可能多的COMID, 可能需要把不同的COMID划为一类, 然后一次发送多包, 最多4包.
或者动态的配置TADMA, 只配置需要定时时间到, 需要发送的COMID, 其他的删除.

这两种方式经过试验, 当comid少或周期长的时候还算稳定, comid增加或周期减少就不稳定了, 需要进一步优化程序.


将driver中的文件覆盖linux源码中的文件重新编译
调试信息的打印使用pr_debug宏而不能用printf, 在tadma驱动文件最开头输入#define DEBUG, 重新编译, 打印debug信息会影响实时性





